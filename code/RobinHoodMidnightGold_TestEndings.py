# -*- coding: utf-8 -*-
"""RobinHoodMidnightGold.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m6-ui8XAjSCa-F0P9QZ9EKjnSzZcd7KW
"""

# Robin Hood: Midnight Gold – Text Adventure
# ------------------------------------------
# This program is a text-based game where the player makes numbered choices
# to guide Robin Hood through different paths and endings.

#Declare and initialise variable choice as an integer
#In Python you don’t pre-declare types like in some other languages.
#Inside each function you already assign choice = input(...), so these global lines are never used.
#They are simply here to represent the concept as you would need them in pseuducode.
#choice = int
#choice = 0

def start_game():
    #Opening scene.
    print("Robin Hood: Midnight Gold\n")
    print("The moon hangs low over Sherwood Forest. Owls call across the dark canopy.")
    print("You, Robin Hood, crouch near a mossy oak beside Little John and Maid Marian.")
    print("Scouts whisper that the Sheriff’s gold convoy will pass through the forest within the hour.")
    print("Your mission: outsmart the Sheriff and deliver the gold to Nottingham’s poor.\n")

    # Decision A – player chooses 1 or 2
    decision_a()


def decision_a():
    #Decision A – First Move.
    print("Quick! Make your first move:")
    print("1. Scout the convoy first")
    print("2. Set a trap immediately")
    choice = input("Choose 1 or 2: ")

    #Choice A1 Scout
    if choice == "1":
        branch_a1()
    #Choice A2 Trap
    elif choice == "2":
        branch_a2()

   #Invalid Entry
    else:
        print("Please enter 1 or 2.")
        decision_a()  # ask again if input is invalid


def branch_a1():
    #Branch A1 – Scout the Convoy.
    print("\nYou slip through the trees like a shadow.")
    print("From a ridge you see torches flicker: four wagons of gold, guarded by a dozen soldiers.")
    print("You overhear their route and timing and return to the hideout.\n")

    #Decision A1
    decision_a1()


def decision_a1():
    #Decision A1 – Next Tactic.
    print("What will be your next tactic?")
    print("1. Ambush at the stone bridge")
    print("2. Sneak into the camp at night")
    choice = input("Choose 1 or 2: ")

    #Choice A1.B1 Ambush
    if choice == "1":
        path_a1b1()
    #Choice A1.B2 Sneak
    elif choice == "2":
        path_a1b2()
    #Invalid entry
    else:
        print("Please enter 1 or 2.")
        decision_a1() # ask again if input is invalid


def path_a1b1():
    #Path A1.B1 – Ambush at the Bridge.
    print("\nThe wagons clatter across the old stone bridge.")
    print("At your signal, ropes snap tight. The first cart overturns, blocking the way.")
    print("Your archers rain arrows on the startled guards. The Sheriff’s men surrender without a fight.\n")

    #Decision A1.B1
    decision_a1b1()


def decision_a1b1():
    #Decision A1.B1 Final Action
    print("It's your big moment - what's your final action?")
    print("1. Free the prisoners and send the gold to the poor.")
    print("2. Take a share and vanish into Sherwood.")
    choice = input("Choose 1 or 2: ")

    #End1 Free the prisoners
    if choice == "1":
        end1()
    #End2 Take a share
    elif choice == "2":
        end2()
    #Invalid Entry
    else:
        print("Please enter 1 or 2.")
        decision_a1b1() # ask again if input is invalid


def path_a1b2():
    #Path A1.B2 – Sneak into the Camp.
    print("\nNight falls. You creep into the Sheriff’s camp.")
    print("A twig snaps under Little John’s boot. The camp erupts in shouts and flashing steel.\n")

    #Decision A1.B2
    decision_a1b2()


def decision_a1b2():
    #Decision A1.B2 – Fight or Escape
    print("Quick, what will you do?!")
    print("1. Fight")
    print("2. Escape empty-handed")
    choice = input("Choose 1 or 2: ")

    #End3 Fight
    if choice == "1":
        end3()
    #End4 Escape
    elif choice == "2":
        end4()
    #Invalid Entry
    else:
        print("Please enter 1 or 2.")
        decision_a1b2() # ask again if input is invalid


def branch_a2():
    #Branch A2 – Set a Trap Immediately.
    print("\nWithout scouting, you and your band rush to rig ropes and spikes along the forest road.")
    print("The night air hums with urgency. You hope you have chosen the right path.\n")

    #Decision A2
    decision_a2()


def decision_a2():
    #Decision A2 – Ambush Style.
    print("Decision A2 – Ambush Style")
    print("1. Hide nearby and wait")
    print("2. Send Little John as a decoy")
    choice = input("Choose 1 or 2: ")

    #End5 Hide and Wait
    if choice == "1":
        end5()
    #A2.B3 Decoy
    elif choice == "2":
        path_a2b3()
    #Invalid Entry
    else:
        print("Please enter 1 or 2.")
        decision_a2() # ask again if input is invalid


def path_a2b3():
    #A2.B3 – Send Little John as Decoy.
    print("\nLittle John strolls into the road singing loudly.")
    print("But the Sheriff anticipated the ploy: hidden crossbowmen leap from the shadows.\n")

    #Decision A2.B3
    decision_a2b3()


def decision_a2b3():
    #A2.B3 – Last Stand or Surrender.
    print("Choose: make your last stand or surrender.")
    print("1. Last stand - fight.")
    print("2. Give in and surrender.")
    choice = input("Choose 1 or 2: ")

    #End3 Fight
    if choice == "1":
        end3()
    #End6 Surrender
    elif choice == "2":
        end6()
    #Invalid Entry
    else:
        print("Please enter 1 or 2.")
        decision_a2b3() # ask again if input is invalid


#Ending

def end1():
    #End1 – Success ending.
    print("\nSUCCESS!")
    print("Cheers rise in Nottingham as bread and coins feed every hungry family.")
    print("The people sing ballads of Robin Hood’s midnight victory.")
    print("Game Over.")


def end2():
    #End2 – Failure: Took a share and vanished.
    print("\nFAILURE.")
    print("Guards regroup and pursue. The Sheriff swears vengeance, and the poor remain hungry.")
    print("Game Over.")


def end3():
    #End3 – Failure: Fought and were captured.
    print("\nFAILURE.")
    print("Outnumbered, you and your band are captured.")
    print("Game Over.")


def end4():
    #End4 – Failure: Escaped empty-handed.
    print("\nFAILURE.")
    print("You save your lives but lose the gold.")
    print("Game Over.")


def end5():
    #End5 – Failure: Hid and lost the gold.
    print("\nFAILURE.")
    print("The convoy looks like it will pass directly into your unscouted trap.")
    print("The ropes tighten perfectly, overturning the first cart.")
    print("However another highwayman ambushes them before you can get there and steals the gold.")
    print("You would have seen them if you had checked more thoroughly.")
    print("You leave with nothing.")
    print("Game Over.")


def end6():
    #End6 – Failure: Surrendered.
    print("\nFAILURE.")
    print("Chains and the dungeon await.")
    print("Game Over.")


# Run the game if the file is executed directly.
if __name__ == "__main__":
    start_game()
#It isn’t strictly necessary for the game to work if you always plan to run it by pasting everything into an interactive Python session and calling start_game() yourself.
#But it is best practice and very helpful if you save this script as a .py file and run it from the command line or double-click it.
#Here’s why that if __name__ == "__main__": block matters:
#Automatic start when run directly
#When you run python robin_hood_game.py, Python sets the special variable __name__ to "__main__".
#The condition is true, so start_game() runs right away and the story begins without you typing anything else.
#Safe importing
#If you later import robin_hood_game into another Python file (for testing or reusing functions), __name__ will not be "__main__".
#That means start_game() will not run automatically and accidentally start printing the story.
#Instead, you can call start_game() only when you really want to.
#So it isn’t required for quick experiments, but for a real script it’s recommended.

# TESTS FOR ALL ENDINGS of Robin Hood: Midnight Gold
# --------------------------------------------------
# These tests automatically run the text adventure using Python's unittest framework,
# feeding in pre-set choices and checking that the expected ending text appears.

import unittest
from unittest.mock import patch
from io import StringIO


# ========== TEST FOR ENDING 1 (SUCCESS) ==========
class TestRobinHoodGame_End1(unittest.TestCase):
    def test_success_path(self):
        """
        Check that choosing Scout -> Ambush -> Free prisoners
        produces the SUCCESS! ending.
        """
        test_inputs = ['1', '1', '1']     # path to End1
        expected_text = "SUCCESS!"
        with patch('builtins.input', side_effect=test_inputs):
            with patch('sys.stdout', new=StringIO()) as fake_out:
                start_game()
                output = fake_out.getvalue()
        print("\nEnd1 test path:", test_inputs)  # show path taken
        print("End1 captured output:\n", output)  # show full story text
        self.assertIn(expected_text, output)


# ========== TEST FOR ENDING 2 ==========
class TestRobinHoodGame_End2(unittest.TestCase):
    def test_take_share_and_vanish(self):
        """
        Check that choosing Scout -> Ambush -> Take a share and vanish
        produces the failure message linked to End2.
        """
        test_inputs = ['1', '1', '2']     # path to End2
        expected_text = "FAILURE."
        with patch('builtins.input', side_effect=test_inputs):
            with patch('sys.stdout', new=StringIO()) as fake_out:
                start_game()
                output = fake_out.getvalue()
        print("\nEnd2 test path:", test_inputs)
        print("End2 captured output:\n", output)
        self.assertIn(expected_text, output)


# ========== TEST FOR ENDING 3 ==========
class TestRobinHoodGame_End3(unittest.TestCase):
    def test_fight_and_captured(self):
        """
        Check that choosing Scout -> Sneak -> Fight
        produces the failure message linked to End3.
        """
        test_inputs = ['1', '2', '1']     # path to End3
        expected_text = "FAILURE."
        with patch('builtins.input', side_effect=test_inputs):
            with patch('sys.stdout', new=StringIO()) as fake_out:
                start_game()
                output = fake_out.getvalue()
        print("\nEnd3 test path:", test_inputs)
        print("End3 captured output:\n", output)
        self.assertIn(expected_text, output)


# ========== TEST FOR ENDING 4 ==========
class TestRobinHoodGame_End4(unittest.TestCase):
    def test_escape_empty_handed(self):
        """
        Check that choosing Scout -> Sneak -> Escape empty-handed
        produces the failure message linked to End4.
        """
        test_inputs = ['1', '2', '2']     # path to End4
        expected_text = "FAILURE."
        with patch('builtins.input', side_effect=test_inputs):
            with patch('sys.stdout', new=StringIO()) as fake_out:
                start_game()
                output = fake_out.getvalue()
        print("\nEnd4 test path:", test_inputs)
        print("End4 captured output:\n", output)
        self.assertIn(expected_text, output)


# ========== TEST FOR ENDING 5 ==========
class TestRobinHoodGame_End5(unittest.TestCase):
    def test_hide_and_wait(self):
        """
        Check that choosing Set a trap immediately -> Hide nearby and wait
        produces the failure message linked to End5.
        """
        test_inputs = ['2', '1']          # path to End5
        expected_text = "FAILURE."
        with patch('builtins.input', side_effect=test_inputs):
            with patch('sys.stdout', new=StringIO()) as fake_out:
                start_game()
                output = fake_out.getvalue()
        print("\nEnd5 test path:", test_inputs)
        print("End5 captured output:\n", output)
        self.assertIn(expected_text, output)


# ========== TEST FOR ENDING 6 ==========
class TestRobinHoodGame_End6(unittest.TestCase):
    def test_surrender(self):
        """
        Check that choosing Set a trap immediately -> Send Little John as a decoy -> Surrender
        produces the failure message linked to End6.
        """
        test_inputs = ['2', '2', '2']     # path to End6
        expected_text = "FAILURE."
        with patch('builtins.input', side_effect=test_inputs):
            with patch('sys.stdout', new=StringIO()) as fake_out:
                start_game()
                output = fake_out.getvalue()
        print("\nEnd6 test path:", test_inputs)
        print("End6 captured output:\n", output)
        self.assertIn(expected_text, output)


# ----- Run all tests in this cell -----
# unittest.main() discovers every class above and runs each test_* method.
# argv=[''] stops unittest from reading notebook arguments.
# exit=False keeps the Colab kernel alive after testing.
unittest.main(argv=[''], exit=False)