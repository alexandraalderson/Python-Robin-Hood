# -*- coding: utf-8 -*-
"""RobinHoodMidnightGold_TestEndings.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xM-3XH-Qa_goKPd0Yk8gUQmeluqmApPg
"""

# Commented out IPython magic to ensure Python compatibility.
# TESTS FOR ALL ENDINGS of Robin Hood: Midnight Gold
# --------------------------------------------------
# These tests automatically run the text adventure using Python's unittest framework,
# feeding in pre-set choices and checking that the expected ending text appears.

#Use !wget to fetch the raw file from GitHub
#This downloads the file into the notebookâ€™s current working directory so Python can import it.
!git clone https://github.com/alexandraalderson/Python-Robin-Hood.git
# %cd Python-Robin-Hood/code

import unittest
from unittest.mock import patch
from io import StringIO

#Import Robin Hood Game
from RobinHoodMidnightGold import start_game


# ========== TEST FOR ENDING 1 (SUCCESS) ==========
class TestRobinHoodGame_End1(unittest.TestCase):
    def test_success_path(self):
        """
        Check that choosing Scout -> Ambush -> Free prisoners
        produces the SUCCESS! ending.
        """
        test_inputs = ['1', '1', '1']     # path to End1
        expected_text = "SUCCESS!"
        with patch('builtins.input', side_effect=test_inputs):
            with patch('sys.stdout', new=StringIO()) as fake_out:
                start_game()
                output = fake_out.getvalue()
        print("\nEnd1 test path:", test_inputs)  # show path taken
        print("End1 captured output:\n", output)  # show full story text
        self.assertIn(expected_text, output)


# ========== TEST FOR ENDING 2 ==========
class TestRobinHoodGame_End2(unittest.TestCase):
    def test_take_share_and_vanish(self):
        """
        Check that choosing Scout -> Ambush -> Take a share and vanish
        produces the failure message linked to End2.
        """
        test_inputs = ['1', '1', '2']     # path to End2
        expected_text = "FAILURE."
        with patch('builtins.input', side_effect=test_inputs):
            with patch('sys.stdout', new=StringIO()) as fake_out:
                start_game()
                output = fake_out.getvalue()
        print("\nEnd2 test path:", test_inputs)
        print("End2 captured output:\n", output)
        self.assertIn(expected_text, output)


# ========== TEST FOR ENDING 3 ==========
class TestRobinHoodGame_End3(unittest.TestCase):
    def test_fight_and_captured(self):
        """
        Check that choosing Scout -> Sneak -> Fight
        produces the failure message linked to End3.
        """
        test_inputs = ['1', '2', '1']     # path to End3
        expected_text = "FAILURE."
        with patch('builtins.input', side_effect=test_inputs):
            with patch('sys.stdout', new=StringIO()) as fake_out:
                start_game()
                output = fake_out.getvalue()
        print("\nEnd3 test path:", test_inputs)
        print("End3 captured output:\n", output)
        self.assertIn(expected_text, output)


# ========== TEST FOR ENDING 4 ==========
class TestRobinHoodGame_End4(unittest.TestCase):
    def test_escape_empty_handed(self):
        """
        Check that choosing Scout -> Sneak -> Escape empty-handed
        produces the failure message linked to End4.
        """
        test_inputs = ['1', '2', '2']     # path to End4
        expected_text = "FAILURE."
        with patch('builtins.input', side_effect=test_inputs):
            with patch('sys.stdout', new=StringIO()) as fake_out:
                start_game()
                output = fake_out.getvalue()
        print("\nEnd4 test path:", test_inputs)
        print("End4 captured output:\n", output)
        self.assertIn(expected_text, output)


# ========== TEST FOR ENDING 5 ==========
class TestRobinHoodGame_End5(unittest.TestCase):
    def test_hide_and_wait(self):
        """
        Check that choosing Set a trap immediately -> Hide nearby and wait
        produces the failure message linked to End5.
        """
        test_inputs = ['2', '1']          # path to End5
        expected_text = "FAILURE."
        with patch('builtins.input', side_effect=test_inputs):
            with patch('sys.stdout', new=StringIO()) as fake_out:
                start_game()
                output = fake_out.getvalue()
        print("\nEnd5 test path:", test_inputs)
        print("End5 captured output:\n", output)
        self.assertIn(expected_text, output)


# ========== TEST FOR ENDING 6 ==========
class TestRobinHoodGame_End6(unittest.TestCase):
    def test_surrender(self):
        """
        Check that choosing Set a trap immediately -> Send Little John as a decoy -> Surrender
        produces the failure message linked to End6.
        """
        test_inputs = ['2', '2', '2']     # path to End6
        expected_text = "FAILURE."
        with patch('builtins.input', side_effect=test_inputs):
            with patch('sys.stdout', new=StringIO()) as fake_out:
                start_game()
                output = fake_out.getvalue()
        print("\nEnd6 test path:", test_inputs)
        print("End6 captured output:\n", output)
        self.assertIn(expected_text, output)


# ----- Run all tests in this cell -----
# unittest.main() discovers every class above and runs each test_* method.
# argv=[''] stops unittest from reading notebook arguments.
# exit=False keeps the Colab kernel alive after testing.
unittest.main(argv=[''], exit=False)